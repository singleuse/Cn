//1. Implement the data link layer framing methods such as character, character-stuffing and bit stuffing.
//a.bit stuffing
#include<stdio.h>
#include<string.h>
void main()
{
char a[50],b[50];
int i=0,j=8,k,count,n;
printf("Enter Input fram (0's & 1's only):\n");
gets(a);
n=strlen(a);
strcpy(b,"01111110");
while(i<n)
{
count=1;
if(a[i]='1')
{
b[j]=a[i];
for(k=i+1;a[k]=='1' && k<n && count<5;k++)
{
j++;
b[j]=a[k];
count++;
if(count==5)
{
j++;
b[j]='/0';
}
i=k;
}
}
else
{
b[j]=a[i];
}
i++;
j++;
}
b[j]='\0';
strcat(b,"01111110");
printf("After stuffing the frame is:\n");
puts(b);
}


  //b character-stuffing
  #include<stdio.h>
#include<string.h>
void main(){
char c[100],d[100];
int i,j,n;
printf("\nEnter the input frame:\n");
gets(c);
n=strlen(c);
d[0]='s';
d[1]='t';
d[2]='x';
for(i=0,j=3;i<n;i++,j++)
{
if((c[i]=='d' && c[i+1]=='1' &&c[i+2]=='e'))
{
d[j]='d';
j++;
d[j]='1';
j++;
n=n+3;
}
else if((c[i]=='s' && c[i+1]=='t' && c[i+2]=='X'))
{
d[j]='s';
j++;
d[j]='t';
j++;
d[j]='x';
j++;
n=n+3;
}
else if((c[i]=='e' && c[i+1]=='t' && c[i+2]=='x'))
{
d[j]='e';
j++;
d[j]='t';

j++;
d[j]='x';
j++;
n=n+3;
}
d[j]=c[i];
}
n=n+2;
n++;
d[n]='e';
n++;
d[n]='t';
n++;
d[n]='x';
n++;
d[n]='\0';
printf("\n \n after character stuff the frame is :\n");
puts(d);
}


//Write a program to compute CRC code for the polynomials CRC-12, CRC-16 and CRC CCIP
#include <stdio.h>
 #include <string.h>
 void main() {
	int i,j,keylen,msglen;
	char input[100], key[30],temp[30],quot[100],rem[30],key1[30];
	printf("Enter Data: ");
	gets(input);
	printf("Enter Key: ");
	gets(key);
	keylen=strlen(key);
	msglen=strlen(input);
	strcpy(key1,key);
	for (i=0;i<keylen-1;i++) {
		input[msglen+i]='0';
	}
	for (i=0;i<keylen;i++)
	 temp[i]=input[i];
	for (i=0;i<msglen;i++) {
		quot[i]=temp[0];
		if(quot[i]=='0')
		 for (j=0;j<keylen;j++)
		 key[j]='0'; else
		 for (j=0;j<keylen;j++)
		 key[j]=key1[j];
		for (j=keylen-1;j>0;j--) {
			if(temp[j]==key[j])
			 rem[j-1]='0'; else
			 rem[j-1]='1';
		}
		rem[keylen-1]=input[i+keylen];
		strcpy(temp,rem);
	}
	strcpy(rem,temp);
	printf("\nQuotient is ");
	for (i=0;i<msglen;i++)
	 printf("%c",quot[i]);
	printf("\nRemainder is ");
	for(i=0;i<keylen-1;i++)
        printf("%c",rem[i]);
	printf("\nFinal data is: ");
	for (i=0;i<msglen;i++)
	 printf("%c",input[i]);
	for (i=0;i<keylen-1;i++)
	 printf("%c",rem[i]);
}

//Implement Dijsktraâ€™s algorithm to compute the shortest path through a network

#include <stdio.h>
 
	void main(){
		int path[10][10],i,j,min,a[10][10],p,st=1,ed=5,stp,edp,t[10],index;
		printf("Enter The cost matrix\n");
		for(i=1;i<=5;i++)
		{
		    for(j=1;j<=5;j++)
		    {
		        scanf("%d",&a[i][j]);
		    }
		}    
		printf("enter the num of paths\n");
		scanf("%d",&p);
		printf("Enter the possible paths\n");
		for(i=1;i<=p;i++)
		{
		for(j=1;j<=5;j++)
		    {
		        scanf("%d",&path[i][j]);
		    }
		}
		for(i=1;i<=p;i++)
		{
			t[i]=0;
			stp=st;
			for(j=1;j<=5;j++){
				edp=path[i][j+1];
				t[i]=t[i]+a[stp][edp];
				if(edp==ed)
				break;
				else
				stp=edp;
			}
		}
		min=t[st];
		index=st;
		for(i=1;i<=p;i++)
		{
			if(min>t[i])
			{
				min=t[i];
				index=i;
			}
		}
 
		printf("Minimun cost %d\n",min);
		printf("Minimun cost path");
		for(i=0;i<=5;i++)
		{
			printf("-->%d",path[index][i]);
			if(path[index][i]==ed)
			break;
		}
 
 
	}
//Implement distance vector routing algorithm for obtaining routing tables at each node.

#include<stdio.h>
struct node
{
unsigned dist[20];
unsigned from[20];
}rt[10];
int main()
{
int dmat[20][20];
int n,i,j,k,count=0;
printf("\nEnter the number of nodes : ");
scanf("%d",&n);printf("Enter the cost matrix :\n");
for(i=0;i<n;i++)
for(j=0;j<n;j++)
{
scanf("%d",&dmat[i][j]);
dmat[i][i]=0;
rt[i].dist[j]=dmat[i][j];
rt[i].from[j]=j;
}
do{
count=0;
for(i=0;i<n;i++)
for(j=0;j<n;j++)
for(k=0;k<n;k++)
if(rt[i].dist[j]>dmat[i][k]+rt[k].dist[j])
{
rt[i].dist[j]=rt[i].dist[k]+rt[k].dist[j];
rt[i].from[j]=k;
count++;
}
}while(count!=0);
for(i=0;i<n;i++)
{
printf("\nState value for router %d is \n",i+1);
for(j=0;j<n;j++)
{
printf("node %d via %d Distance%d\n",j+1,rt[i].from[j]+1,rt[i].dist[j]);
}
}
printf("\n");
}


// Take an example subnet of hosts and obtain a broadcast tree for the subnet.

#include<stdio.h>
#include<stdlib.h>
int i,j,k,a,b,u,v,n,ne=1;
int min,mincost=0,cost[9][9],parent[9];
int find(int);
int uni(int,int);
void main()
{
	
	printf("\n\tImplementation of Kruskal's algorithm\n");
	printf("\nEnter the no. of vertices:");
	scanf("%d",&n);
	printf("\nEnter the cost adjacency matrix:\n");
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=n;j++)
		{
			scanf("%d",&cost[i][j]);
			if(cost[i][j]==0)
				cost[i][j]=99;
		}
	}
	printf("The edges of Minimum Cost Spanning Tree are\n");
	while(ne < n)
	{
		for(i=1,min=99;i<=n;i++)
		{
			for(j=1;j <= n;j++)
			{
				if(cost[i][j] < min)
				{
					min=cost[i][j];
					a=u=i;
					b=v=j;
				}
			}
		}
		u=find(u);
		v=find(v);
		if(uni(u,v))
		{
			printf("%d edge (%d,%d) =%d\n",ne++,a,b,min);
			mincost +=min;
		}
		cost[a][b]=cost[b][a]=99;
	}
	printf("\n\tMinimum cost = %d\n",mincost);
}
int find(int i)
{
	while(parent[i])
	i=parent[i];
	return i;
}
int uni(int i,int j)
{
	if(i!=j)
	{
		parent[j]=i;
		return 1;
	}
	return 0;
}
